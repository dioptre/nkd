//-----------------------------------------------------------------------------
//
// ADX4 Toolkit
//
// Copyright 2009. Mining Industry Geospatial Consortium.
//
// This file is part of the ADX4 Toolkit.
//
//    The ADX4 toolkit is free software: you can redistribute it and/or modify
//    it under the terms of the GNU Lesser General Public License as published
//    by the Free Software Foundation, either version 3 of the License, or
//    (at your option) any later version.
//
//    The ADX4 toolkit is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//    GNU Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public License
//    along with The ADX4 toolkit.  If not, see <http://www.gnu.org/licenses/>.
//
//-----------------------------------------------------------------------------

using System;
using System.Text;
using System.ComponentModel;
using System.Collections.Generic;
using System.Runtime.Serialization.Formatters.Binary;
using System.Reflection;
using System.Xml.Serialization;
using System.Xml;
using System.IO;

namespace ADX4
{
    #region ADX
    public partial class ADX
    {
        #region Constants
        public const String c_ADX4_Xsd = "ADX4.xsd";
        public const String c_ADX4Dictionary_Xsd = "ADX4Dictionary.xsd";
        public const String c_ADX4_NameSpace = "http://www.adx4.org/ADX/4";
        public const String c_ADX4Dictionary_NameSpace = "http://www.adx4.org/ADX/4/Dictionary";
        #endregion

        #region Static Events
        static public event XmlElementEventHandler OnLoadUnknownElements;
        static public event XmlAttributeEventHandler OnLoadUnknownAttributes;
        static public event XmlNodeEventHandler OnLoadUnknownNode;
        static public event UnreferencedObjectEventHandler OnLoadUnreferencedObjects;
        #endregion

        #region Static Methods
        static public ADX Load(String fileName)
        {
            if (fileName == null)
                return null;

            // Deserialize the ADX document from an XML file
            ADX document = null;
            try
            {

                XmlSerializer xmlSerializer = new XmlSerializer(typeof(ADX));

                FileStream adxStream = new FileStream(fileName, FileMode.Open);
                XmlReader xmlReader = XmlReader.Create(adxStream);

                // Ignore mal-formed XML for now
                XmlDeserializationEvents events = new XmlDeserializationEvents();
                events.OnUnknownElement = ADX.OnLoadUnknownElements;
                events.OnUnknownAttribute = ADX.OnLoadUnknownAttributes;
                events.OnUnknownNode = ADX.OnLoadUnknownNode;
                events.OnUnreferencedObject = ADX.OnLoadUnreferencedObjects;

                // Get the ADX document
                document = xmlSerializer.Deserialize(xmlReader, events) as ADX;

                adxStream.Close();
            }

            // Trap and throw the any exceptions higher up
            catch (System.Exception exc)
            {
                throw exc;
            }

            return document;
        }
        #endregion
    }
    #endregion

    #region SampleReference
    /// <summary>
    /// Enhancements to ADX autogenerated class <seealso cref="SampleReference"/>
    /// </summary>
    public partial class SampleReference
    {
        public SampleReference()
        {
        }

        public SampleReference(String id)
        {
            this.IdRef = id;
        }
    }
    #endregion

    #region ProcessingGroup
    /// <summary>
    /// Enhancements to ADX autogenerated class <seealso cref="ProcessingGroup"/>
    /// </summary>
    public partial class ProcessingGroup
    {
        public override string ToString()
        {

            return String.IsNullOrEmpty(this.Id) ? "?" : this.Id;
        }
    }
    #endregion

    #region Measurement
    /// <summary>
    /// Enhancements to ADX autogenerated class <seealso cref="Measurement"/>
    /// </summary>
    public partial class Measurement
    {
        public override string ToString()
        {

            return String.IsNullOrEmpty(this.Property) ? "?" : this.Property;
        }
    }
    #endregion

    #region Result
    /// <summary>
    /// Enhancements to ADX autogenerated class <seealso cref="Result"/>
    /// </summary>
    public partial class Result
    {
        public override string  ToString()
        {
            if (this.Sample == null)
                return "?";

            StringBuilder fullIdBuilder = new StringBuilder();
            fullIdBuilder.Length = 0;
            for (int i = 0; i < this.Sample.Length; i++)
            {
                fullIdBuilder.Append(this.Sample[i].IdRef);
                if (i < this.Sample.Length - 2)
                    fullIdBuilder.Append(",");
            }

            return fullIdBuilder.ToString();
        }
    }
    #endregion

    #region Sample
    /// <summary>
    /// Enhancements to ADX autogenerated class <seealso cref="Samples"/>
    /// </summary>
    public partial class Samples
    {
        /// <summary>
        /// Finds the sample matching the specified sample reference.
        /// </summary>
        /// <param name="sampleRef">The sample reference.</param>
        /// <returns>Matching sample</returns>
        public Sample Find(SampleReference sampleRef)
        {
            foreach (Sample sample in this.Sample)
                if (String.Equals(sample.Id, sampleRef.IdRef))
                    return sample;

            return null;
        }
    }
    #endregion

    #region ChainOfCustodyBatch
    /// <summary>
    /// Enhancements to ADX autogenerated class <seealso cref="ChainOfCustodyBatch"/>
    /// </summary>
    public partial class ChainOfCustodyBatch
    {
        /// <summary>
        /// Finds the chain of custody sample that matches the requested sample reference.
        /// </summary>
        /// <param name="sampleRef">The sample ref.</param>
        /// <returns>matching chain of custody sample</returns>
        public ChainOfCustodySample Find(SampleReference sampleRef)
        {
            foreach (ChainOfCustodySample sample in this.SampleMaterial)
            {
                if (sample.Sample.Length != 1)
                    continue;
                if (sample.Sample == null)
                    continue;

                if (String.Equals(sample.Sample[0].IdRef, sampleRef.IdRef))
                    return sample;
            }

            return null;
        }
    }
    #endregion

    #region Process
    /// <summary>
    /// Enhancements to ADX autogenerated class <seealso cref="Process"/>
    /// </summary>
    public partial class Process
    {
        /// <summary>
        /// Performs a deep copy of this process.
        /// </summary>
        /// <returns>Cloned process</returns>
        public Process Clone()
        {
            try
            {
                BinaryFormatter serializer = new BinaryFormatter();
                MemoryStream buffer = new MemoryStream();
                serializer.Serialize(buffer, this);
                return serializer.Deserialize(buffer) as Process;
            }
            catch (System.Exception exc)
            {
                return null;
            }
        }

        // TODO finish this searching procedure
        public Procedure FindProcedure(String procedureName)
        {
            return SearchForProcedureByName(this.Destination, procedureName);
        }

        // TODO Finish FindProcedure procedure   
        private Procedure SearchForProcedureByName(MaterialDestination parentDestination, String procedureName)
        {
            return null;
        }
    }
    #endregion
    
    #region Procedure
    /// <summary>
    /// Enhancements to ADX autogenerated class <seealso cref="Procedure"/>
    /// </summary>
    public partial class Procedure
    {
        /// <summary>
        /// Gets a more readable version of the procedure name (by removing the word Procedure from the end of it).
        /// </summary>
        /// <param name="name">The name.</param>
        /// <returns>Readable procedure name</returns>
        public static String Label(String name)
        {
            return name.EndsWith("Procedure") ? name.Substring(0, name.Length - 9) : name;
        }

        /// <summary>
        /// Gets the destinations on this procedure.
        /// </summary>
        /// <returns>List of destinations</returns>
        public List<MaterialDestination> GetDestinations()
        {
            List<MaterialDestination> destinations = new List<MaterialDestination>();

            // Get the procedure's properties
            PropertyInfo[] propertyInfos = this.GetType().GetProperties();
            foreach (PropertyInfo propertyInfo in propertyInfos)
            {
                // Is this property a MaterialDestination ?
                if (propertyInfo.PropertyType.IsSubclassOf(typeof(MaterialDestination)) || propertyInfo.PropertyType == typeof(MaterialDestination))
                {
                    // If so then add it to the list of destinations ?
                    System.Object getValue = propertyInfo.GetValue(this, null);

                    if (getValue == null)
                    {
                        MaterialDestination destination = new MaterialDestination();
                        propertyInfo.SetValue(this, destination, null);
                        destinations.Add(destination);
                    }
                    else if (getValue is MaterialDestination)
                        destinations.Add(getValue as MaterialDestination);
                }
                // Is the property a list of objects ?
                else if (propertyInfo.PropertyType.IsArray)
                {
                    System.Object getValue = propertyInfo.GetValue(this, null);
                    if (getValue != null)
                    {
                        // Check each object to see if it is a MaterialDestination
                        foreach (Object thisElement in getValue as Array)
                        {
                            if (thisElement is MaterialDestination)
                                destinations.Add(thisElement as MaterialDestination);
                        }
                    }
                }
            }

            return destinations;
        }
    }
    #endregion

    #region SplittingProcedure
    /// <summary>
    /// Enhancements to ADX autogenerated class <seealso cref="SplittingProcedure"/>
    /// </summary>
    public partial class SplittingProcedure
    {
        public SplittingProcedure()
        {
            this.destinationField = new MaterialDestination[2];
            this.destinationField[0] = new MaterialDestination();
            this.destinationField[1] = new MaterialDestination();
        }
    }
    #endregion

    #region ParticleSizeReductionProcedure
    /// <summary>
    /// Enhancements to ADX autogenerated class <seealso cref="ParticleSizeReductionProcedure"/>
    /// </summary>
    public partial class ParticleSizeReductionProcedure
    {
        public ParticleSizeReductionProcedure()
        {
            this.Screen = new Screen();
        }
    }
    #endregion

    #region Quantity
    /// <summary>
    /// Enhancements to ADX autogenerated class <seealso cref="Quantity"/>
    /// </summary>
    [System.ComponentModel.TypeConverter(typeof(QuantityConverter))]
    public partial class Quantity
    {
        public Quantity()
        {
            this.Value = "";
            this.UOM = Enum.GetName(typeof(PropertyTypeStrict), UOMStrict.Unspecified);
        }

        public override string ToString()
        {
            if (!String.Equals(this.UOM, Enum.GetName(typeof(PropertyTypeStrict), UOMStrict.Unspecified)))
                return String.Concat(this.Value.ToString(), " ", this.UOM.ToString());
            return "";
        }
    }

    /// <summary>
    /// TypeConverter to convert a quantity into a string format.
    /// </summary>
    public class QuantityConverter : ExpandableObjectConverter
    {
        public override bool CanConvertTo(ITypeDescriptorContext context, Type destinationType)
        {
            if (destinationType == typeof(Quantity))
                return true;

            return base.CanConvertTo(context, destinationType);
        }
        public override object ConvertTo(ITypeDescriptorContext context, System.Globalization.CultureInfo culture, object value, Type destinationType)
        {
            if (destinationType == typeof(System.String) && value is Quantity)
                return value.ToString();

            return base.ConvertTo(context, culture, value, destinationType);
        }
    }
    #endregion 

    #region Material
    /// <summary>
    /// Enhancements to ADX autogenerated class <seealso cref="MaterialTarget"/>
    /// </summary>
    [System.ComponentModel.TypeConverter(typeof(MaterialTargetConverter))]
    public partial class MaterialTarget
    {
        public MaterialTarget()
        {
        }
    }

    /// <summary>
    /// TypeConverter to convert a MaterialTarget into a string format.
    /// </summary>
    public class MaterialTargetConverter : ExpandableObjectConverter
    {
        public override bool CanConvertTo(ITypeDescriptorContext context, Type destinationType)
        {
            if (destinationType == typeof(MaterialTarget))
                return true;

            return base.CanConvertTo(context, destinationType);
        }

        public override object ConvertTo(ITypeDescriptorContext context, System.Globalization.CultureInfo culture, object value, Type destinationType)
        {
            if (destinationType == typeof(System.String) && value is MaterialTarget)
            {
                MaterialTarget target = value as MaterialTarget;
                return "Target";
            }

            return base.ConvertTo(context, culture, value, destinationType);
        }
    }
    #endregion

    #region MaterialDestination
    /// <summary>
    /// Enhancements to ADX autogenerated class <seealso cref="MaterialDestination"/>
    /// </summary>
    [System.ComponentModel.TypeConverter(typeof(MaterialConverter))]
    public partial class MaterialDestination
    {
        public MaterialDestination()
        {
            this.Description = "";
        }

        /// <summary>
        /// Performs a deep copy of the MaterialDestination.
        /// </summary>
        /// <returns>Deep copy of the MaterialDestination</returns>
        public MaterialDestination Clone()
        {
            try
            {
                BinaryFormatter serializer = new BinaryFormatter();
                MemoryStream buffer = new MemoryStream();
                serializer.Serialize(buffer, this);
                buffer.Seek(0, SeekOrigin.Begin);
                return serializer.Deserialize(buffer) as MaterialDestination;
            }
            catch (System.Exception exc)
            {
                return null;
            }
        }

        public override string ToString()
        {
            if (this.Mass == null || String.Equals(this.Mass.UOM, Enum.GetName(typeof(PropertyTypeStrict), UOMStrict.Unspecified)))
            {
                if (String.IsNullOrEmpty(this.Name) && String.IsNullOrEmpty(this.Type))
                    return "";
                if (!String.IsNullOrEmpty(this.Name) && String.IsNullOrEmpty(this.Type))
                    return this.Name;
                if (String.IsNullOrEmpty(this.Name) && !String.IsNullOrEmpty(this.Type))
                    return this.Type;

                return String.Concat(this.Type, " : ", this.Name);
            }
            else
            {
                if (String.IsNullOrEmpty(this.Name) && String.IsNullOrEmpty(this.Type))
                    return this.Mass.ToString();
                if (!String.IsNullOrEmpty(this.Name) && String.IsNullOrEmpty(this.Type))
                    return String.Concat(this.Name, " / ", this.Mass.ToString());
                if (String.IsNullOrEmpty(this.Name) && !String.IsNullOrEmpty(this.Type))
                    return String.Concat(this.Type, " / ", this.Mass.ToString());

                return String.Concat(String.Concat(this.Type, " : ", this.Name), " / ", this.Mass.ToString());
            }
        }

        /// <summary>
        /// Gets a value indicating whether this instance has a valid material target. 
        /// </summary>
        /// <value>
        /// 	<c>true</c> if this instance is valid target; otherwise, <c>false</c>.
        /// </value>
        public Boolean IsValidTarget
        {
            get
            {
                if (!this.HasTarget)
                    return true;

                if (this.Target.HasProcedure())
                {
                    if (this.Target.HasProcedureName() || this.Target.HasProcessName() || this.Target.HasProtocol())
                        return false;
                }
                else if (this.Target.HasProcedureName() || this.Target.HasProcessName() || this.Target.HasProtocol())
                {
                    if (this.Target.HasProcedure())
                        return false;
                }

                return true;
            }
        }

        /// <summary>
        /// Determines if this destination has a valid target. 
        /// </summary>
        /// <value>
        /// 	<c>true</c> if this destination has target; otherwise, <c>false</c>.
        /// </value>
        public Boolean HasTarget
        {
            get
            {
                if (this.Target == null)
                    return false;
                if (!String.IsNullOrEmpty(this.Target.ProcessRef))
                    return true;
                if (!String.IsNullOrEmpty(this.Target.ProcedureRef))
                    return true;
                if (!String.IsNullOrEmpty(this.Target.MaterialSourceRef))
                    return true;
                if (this.Target.Procedure != null && this.Target.Procedure.Length > 0)
                    return true;
                return false;
            }
        }
    }

    /// <summary>
    /// TypeConverter to convert a MaterialDestination into a string format.
    /// </summary>
    public class MaterialConverter : ExpandableObjectConverter
    {
        public override bool CanConvertTo(ITypeDescriptorContext context, Type destinationType)
        {
            if (destinationType == typeof(MaterialDestination))
                return true;

            return base.CanConvertTo(context, destinationType);
        }

        public override object ConvertTo(ITypeDescriptorContext context, System.Globalization.CultureInfo culture, object value, Type destinationType)
        {
            if (destinationType == typeof(System.String) && value is MaterialDestination)
                return value.ToString();

            return base.ConvertTo(context, culture, value, destinationType);
        }
    }
    #endregion

    #region MaterialTarget
    /// <summary>
    /// Enhancements to ADX autogenerated class <seealso cref="MaterialTarget"/>
    /// </summary>
    public partial class MaterialTarget
    {
        public MaterialTarget(MaterialTarget defaultTarget)
        {
            if (defaultTarget != null)
            {
                this.ProtocolRef = defaultTarget.ProtocolRef;
                this.ProcessRef = defaultTarget.ProcessRef;
                this.ProcedureRef = defaultTarget.ProcedureRef;
                this.MaterialSourceRef = defaultTarget.MaterialSourceRef;
            }
        }

        public override string ToString()
        {
            StringBuilder builder = new StringBuilder();
            if (this.HasProtocol())
                builder.AppendFormat("ProcotolRef = [{0}] ", this.ProtocolRef);
            if (this.HasProcessName())
                builder.AppendFormat("ProcessRef = [{0}] ", this.ProcessRef);
            if (this.HasProcedureName())
                builder.AppendFormat("ProcedureRef = [{0}] ", this.ProcedureRef);
            if (this.HasProcedure())
                builder.AppendFormat("Explicit Procedures ");
            return builder.ToString();
        }

        /// <summary>
        /// Determines whether this target has protocol.
        /// </summary>
        /// <returns>
        /// 	<c>true</c> if this target has protocol; otherwise, <c>false</c>.
        /// </returns>
        public Boolean HasProtocol()
        {
            if (!String.IsNullOrEmpty(this.ProtocolRef))
                return true;

            return false;
        }

        /// <summary>
        /// Determines whether this target has protocol.
        /// </summary>
        /// <returns>
        /// 	<c>true</c> if this target has protocol; otherwise, <c>false</c>.
        /// </returns>
        public Boolean HasProcessName()
        {
            if (!String.IsNullOrEmpty(this.ProcessRef))
                return true;

            return false;
        }

        /// <summary>
        /// Determines whether this target has a procedure name
        /// </summary>
        /// <returns>
        /// 	<c>true</c> if this target has a procedure name; otherwise, <c>false</c>.
        /// </returns>
        public Boolean HasProcedureName()
        {
            if (!String.IsNullOrEmpty(this.ProcedureRef))
                return true;

            return false;
        }

        /// <summary>
        /// Determines whether this target has material source name.
        /// </summary>
        /// <returns>
        /// 	<c>true</c> if this target has material source name; otherwise, <c>false</c>.
        /// </returns>
        public Boolean HasMaterialSourceName()
        {
            if (!String.IsNullOrEmpty(this.MaterialSourceRef))
                return true;

            return false;
        }

        /// <summary>
        /// Determines whether this target has procedure.
        /// </summary>
        /// <returns>
        /// 	<c>true</c> if this target has a procedure; otherwise, <c>false</c>.
        /// </returns>
        public Boolean HasProcedure()
        {
            if (this.Procedure != null && this.Procedure.Length > 0)
                return true;

            return false;
        }

        /// <summary>
        /// Gets a value indicating whether this target is specified. 
        /// </summary>
        /// <value>
        /// 	<c>true</c> if this target is specified; otherwise, <c>false</c>.
        /// </value>
        public Boolean IsSpecified
        {
            get
            {
                return this.HasProcedure() || this.HasProtocol() || this.HasProcessName() || this.HasProcedureName();
            }
        }
    }
    #endregion

    #region ProcessingPath
    /// <summary>
    /// Enhancements to ADX autogenerated class <seealso cref="ProcessingPath"/>
    /// </summary>
    public partial class ProcessingPath
    {
        /// <summary>
        /// Determines whether the specified <see cref="T:System.Object"/> is equal to the current <see cref="T:System.Object"/>.
        /// </summary>
        /// <param name="obj">The <see cref="T:System.Object"/> to compare with the current <see cref="T:System.Object"/>.</param>
        /// <returns>
        /// true if the specified <see cref="T:System.Object"/> is equal to the current <see cref="T:System.Object"/>; otherwise, false.
        /// </returns>
        /// <exception cref="T:System.NullReferenceException">
        /// The <paramref name="obj"/> parameter is null.
        /// </exception>
        public override bool Equals(object obj)
        {
            if (!(obj is ProcessingPath))
                return false;
            ProcessingPath other = obj as ProcessingPath;

            // Does this processing path have any tags ?
            if (this.Tag == null)
            {
                if (other.Tag == null)
                    return true;
                if (other.Tag.Length == 0)
                    return true;
                return false;
            }

            // Does the other processing path have any tags ?
            if (other.Tag == null)
            {
                if (this.Tag == null)
                    return true;
                if (this.Tag.Length == 0)
                    return true;
                return false;
            }

            // Are they the same lengths ?
            if (other.Tag.Length != this.Tag.Length)
                return false;

            // Compare each tag and see if they are the same 
            for (int i = 0; i < other.Tag.Length; i++)
            {
                if (this.Tag[i] == null)
                {
                    if (other.Tag[i] != null)
                        return false;
                }
                else if (other.Tag[i] == null)
                {
                    if (this.Tag[i] != null)
                        return false;
                }
                else
                {
                    if (String.Compare(this.Tag[i].Type == null ? "" : this.Tag[i].Type, other.Tag[i].Type == null ? "" : other.Tag[i].Type) != 0)
                        return false;

                    if (String.Compare(this.Tag[i].Name == null ? "" : this.Tag[i].Name, other.Tag[i].Name == null ? "" : other.Tag[i].Name) != 0)
                        return false;
                }
            }

            return true;
        }

        /// <summary>
        /// Determines whether this processing path is empty.
        /// </summary>
        /// <returns>
        /// 	<c>true</c> if this processing path is empty; otherwise, <c>false</c>.
        /// </returns>
        public Boolean IsEmpty()
        {
            if (this.Tag == null || this.Tag.Length == 0)
                return true;

            return false;
        }

        public override string ToString()
        {
            if (this.Tag == null)
                return "";

            StringBuilder builder = new StringBuilder();
            Boolean addedFirst = false;

            foreach(ProcessingTag tag in this.Tag)
            {
                if (tag == null)
                    continue;

                if (String.IsNullOrEmpty(tag.Name) && String.IsNullOrEmpty(tag.Type))
                    continue;

                if (!String.IsNullOrEmpty(tag.Name) && String.IsNullOrEmpty(tag.Type))
                    builder.Append(String.Concat((addedFirst ? ", " : ""),tag.Name));
                else if (String.IsNullOrEmpty(tag.Name) && !String.IsNullOrEmpty(tag.Type))
                    builder.Append(String.Concat((addedFirst ? ", " : ""),tag.Type));
                else
                    builder.Append(String.Concat((addedFirst ? ", " : ""),tag.Type, " : ", tag.Name));
                addedFirst = true;
            }
            return builder.ToString();
        }
    }
    #endregion

    #region ProcessingTag
    /// <summary>
    /// Enhancements to ADX autogenerated class <seealso cref="ProcessingTag"/>
    /// </summary>
    public partial class ProcessingTag
    {
        /// <summary>
        /// Checks if the tag equals this name and type
        /// </summary>
        /// <param name="name">The tag name.</param>
        /// <param name="type">The tag type.</param>
        /// <returns>True if they are equal; otherwise false</returns>
        public Boolean Equals(String name, String type)
        {
            if (String.IsNullOrEmpty(name) && String.IsNullOrEmpty(type) && String.IsNullOrEmpty(this.Name) && String.IsNullOrEmpty(this.Type))
                return true;

            if (!String.IsNullOrEmpty(name) && String.IsNullOrEmpty(type) && String.Equals(name,this.Name) && String.IsNullOrEmpty(this.Type))
                return true;

            if (String.IsNullOrEmpty(name) && !String.IsNullOrEmpty(type) && String.IsNullOrEmpty(this.Name) && String.Equals(type, this.Type))
                return true;

            if (!String.IsNullOrEmpty(name) && !String.IsNullOrEmpty(type) && String.Equals(name, this.Name) && String.Equals(type, this.Type))
                return true;

            return false;
        }
    }
    #endregion

    #region AnalysisProcedure
    /// <summary>
    /// Enhancements to ADX autogenerated class <seealso cref="AnalysisProcedure"/>
    /// </summary>
    public partial class AnalysisProcedure
    {
        public override string ToString()
        {
            String assayType = "?";
            if (String.Equals(this.Property, Enum.GetName(typeof(PropertyTypeStrict), PropertyTypeStrict.Unspecified)) && this.Code != null && String.Equals(this.UOM, Enum.GetName(typeof(PropertyTypeStrict), UOMStrict.Unspecified)))
                assayType = String.Format("{0}_{1}_{2}", this.Property, this.Code, this.UOM);
            else if (String.Equals(this.Property, Enum.GetName(typeof(PropertyTypeStrict), PropertyTypeStrict.Unspecified)) && String.Equals(this.UOM, Enum.GetName(typeof(PropertyTypeStrict), UOMStrict.Unspecified)))
                assayType = String.Format("{0}_{1}", this.Property, this.UOM);
            else if (String.Equals(this.Property, Enum.GetName(typeof(PropertyTypeStrict), PropertyTypeStrict.Unspecified)) && this.Code != null)
                assayType = String.Format("{0}_{1}", this.Property, this.Code);
            else if (String.Equals(this.Property, Enum.GetName(typeof(PropertyTypeStrict), PropertyTypeStrict.Unspecified)))
                assayType = String.Format("{0}", this.Property);

            return assayType;
        }
    }
    #endregion
}
